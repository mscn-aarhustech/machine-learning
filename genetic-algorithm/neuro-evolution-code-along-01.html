<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Genetic Algorithm with Float Encoding</title>
</head>
<body>
    <h1>Neuroevolution (Output in Console)</h1>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <script type="module">
        "use strict";

        const PopulationSize = 400;
        const MutationChance = 0.01;
        const MaxGenerations = 5000;
        const ElitismCount = 2;

        const WeightMin = -10;
        const WeightMax = 10;
        const WeightRange = WeightMax - WeightMin;

        const AndGateTestData =[
            {   
                input : [0, 0],
                output : 0
            },
            {   
                input : [0, 1],
                output : 0
            },
             {   
                input : [1, 0],
                output : 0
            },
            {   
                input : [1, 1],
                output : 1
            },
        ];

        const Population = [];
        let TargetGenome = [0, 1, 2, 3];

        const TargetNetwork = createRandomNetwork();

        function encodeNetworkToGenome(network) {
            const genome = [];
            const weightsAndBiases = network.getWeights();
            weightsAndBiases.forEach(tensor => {
                const values = tensor.dataSync();
                for(let i = 0; i < values.length; i++) {
                    const cappedValue = Math.max(WeightMin, Math.min(WeightMax, values[i]));
                    const normalizedValue = (cappedValue - WeightMin) / WeightRange;
                    genome.push(normalizedValue);
                }
            });
            return genome;
        }

        function decodeGenomeToNetwork(genome, neuralNetwork) {

            const shapes = neuralNetwork.getWeights().map(tensor => {
                return { shape : tensor.shape, size : tensor.size};
            });

            const denormalizeWeights = genome.map(gene => gene * WeightRange + WeightMin);

            let index = 0;

            const newTensors = shapes.map(({shape, size }) =>  {
                const values = denormalizeWeights.slice(index, index + size);
                index += size;
                return tf.tensor(values, shape);
            });

            neuralNetwork.setWeights(newTensors);

            newTensors.forEach(t => t.dispose());
        }

        function getRandomGene() {
            return Math.random();
        }

        function createRandomNetwork() {
            const neuralNetwork = tf.sequential();
            
            neuralNetwork.add(
                tf.layers.dense(
                    {
                        units : 1,
                        inputShape : [2],
                        activation : 'sigmoid'
                    }
                )
            );

            return neuralNetwork;
        }

        function createRandomIndividual() {
            const neuralNetwork = createRandomNetwork();
            const genome = encodeNetworkToGenome(neuralNetwork);
            const Individual = {
                "genome": genome,
                "fitness": 0
            };
            return Individual;
        }

        function createInitialPopulation() {
            Population.length = 0;
            for (let i = 0; i < PopulationSize; i++) {
                const randomIndividual = createRandomIndividual();
                Population.push(randomIndividual);
            }
        }

        async function assignFitnessScore() {
            //Population.forEach(individual => {
            for(const individual of Population) {
                let totalDifference = 0;
                
                // Create nn from genome
                const genome = individual.genome;

                //console.log(genome);

                const nn = createRandomNetwork();

                decodeGenomeToNetwork(genome, nn);

                // Test if nn can solve AND logic gate
                //AndGateTestData.forEach(data => {
                for(const data of AndGateTestData) {

                    const inputTensor = tf.tensor2d([data.input]);

                    //console.log(inputTensor);

                    const predictTensor = nn.predict(inputTensor);

                    const predictData = await predictTensor.data();

                    const output = predictData[0];

                    //console.log("output: ", output);

                    totalDifference += Math.abs(data.output - output);
                    
                    inputTensor.dispose();
                    predictTensor.dispose();
                };

                // Assign fitness
                individual.fitness = 1 / (1 + totalDifference);
            };

            Population.sort((a, b) => b.fitness - a.fitness);
        }

        function isTargetReached() {
            return Population[0].fitness <= 0.001;
        }

        function createNewGeneration() {
            const NewGeneration = [];

            const Elite = Population.slice(0, ElitismCount);
            NewGeneration.push(...Elite);

            while (NewGeneration.length < PopulationSize) {
                const ParentA = tournamentSelection();
                const ParentB = tournamentSelection();
                //const child = recombination(ParentA, ParentB);
                const child = wholeArithmeticRecombination(ParentA, ParentB);
                NewGeneration.push(child);
            }

            Population.length = 0;
            Population.push(...NewGeneration);
        }

        function lerp(a, b, lambda) {
            return a * lambda + b * (1 - lambda);
        }

        function wholeArithmeticRecombination(parentA, parentB) {
            let childGenome = [];
            for (let geneIndex = 0; geneIndex < TargetGenome.length; geneIndex++) {
                const shouldMutate = Math.random() < MutationChance;
                if (shouldMutate) {
                    childGenome.push(getRandomGene());
                } else {
                    const lambda = Math.random();
                    childGenome.push(lerp(parentA.genome[geneIndex], parentB.genome[geneIndex], lambda));
                }
            }
            return {
                "genome": childGenome,
                "fitness": 0
            };
        }

        function recombination(parentA, parentB) {
            let childGenome = [];

            for (let geneIndex = 0; geneIndex < TargetGenome.length; geneIndex++) {
                const shouldMutate = Math.random() < MutationChance;
                if (shouldMutate) {
                    childGenome.push(getRandomGene());
                } else {
                    childGenome.push(Math.random() < 0.5 ? parentA.genome[geneIndex] : parentB.genome[geneIndex]);
                }
            }
            return {
                "genome": childGenome,
                "fitness": 0
            };
        }

        function tournamentSelection() {
            const NumParticipants = 2;
            const Participants = [];
            for (let i = 0; i < NumParticipants; i++) {
                const randomIndex = Math.floor(Math.random() * Population.length);
                Participants.push(Population[randomIndex]);
            }
            Participants.sort((a, b) => b.fitness - a.fitness);
            return Participants[0];
        }

        console.log("Starting genetic algorithm...");

        const startTime = performance.now();
        createInitialPopulation();

        let generation = 1;
        let isCompleted = false;

        //do {
            assignFitnessScore();
            
            // if (isTargetReached()) {
            //     isCompleted = true;
            //     break;
            // }
            
            //createNewGeneration();

            //generation++;

        //} while (generation < MaxGenerations);

        console.log(Population);

        // Create nn from genome
        const genome = Population[0].genome;

        //console.log(genome);

        const nn = createRandomNetwork();

        decodeGenomeToNetwork(genome, nn);

        // Test if nn can solve AND logic gate
        //AndGateTestData.forEach(data => {
        for(const data of AndGateTestData) {

            const inputTensor = tf.tensor2d([data.input]);

            //console.log(inputTensor);

            const predictTensor = nn.predict(inputTensor);

            const predictData = await predictTensor.data();

            const output = predictData[0];

            //console.log("output: ", output);

            console.log("input :", data.input, "output :", output, "answer :", data.output);
            
            inputTensor.dispose();
            predictTensor.dispose();
        };
        

        const endTime = performance.now();

        console.log(`Genetic algorithm ran for ${(endTime - startTime).toFixed(1)} milliseconds.`);

    </script>
</body>
</html>

