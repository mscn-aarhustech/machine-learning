<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Genetic Algorithm with Float Encoding</title>
</head>
<body>
    <h1>Genetic Algorithm - Float Encoding (Output in Console)</h1>

    <script>
        "use strict";

        const TargetString = "To be or not to be";
        const Genes = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ 1234567890.,:;-'";
        const PopulationSize = 400;
        const MutationChance = 0.01;
        const MaxGenerations = 1000;
        const ElitismCount = 2;

        const Population = [];
        let TargetGenome;

        function encodeStringToGenome(str) {
            const genome = [];
            for (let i = 0; i < str.length; i++) {
                const char = str[i];
                const index = Genes.indexOf(char);
                if (index === -1) {
                    console.log(`Error: Character "${char}" not found in Genes set.`);
                    genome.push(0.0);
                } else {
                    const normalizedValue = index / (Genes.length - 1);
                    genome.push(normalizedValue);
                }
            }
            return genome;
        }

        function decodeGenomeToString(genome) {
            let str = "";
            for (let i = 0; i < genome.length; i++) {
                const index = Math.round(genome[i] * (Genes.length - 1));
                str += Genes[index] || Genes[0];
            }
            return str;
        }

        TargetGenome = encodeStringToGenome(TargetString);

        function getRandomGene() {
            return Math.random();
        }

        function createRandomIndividual() {
            let genome = [];
            for (let i = 0; i < TargetGenome.length; i++) {
                genome.push(getRandomGene());
            }
            return {
                "genome": genome,
                "fitness": 0
            };
        }

        function createInitialPopulation() {
            Population.length = 0;
            for (let i = 0; i < PopulationSize; i++) {
                const randomIndividual = createRandomIndividual();
                Population.push(randomIndividual);
            }
        }

        function assignFitnessScore() {
            Population.forEach(individual => {
                let totalDifference = 0;
                for (let geneIndex = 0; geneIndex < TargetGenome.length; geneIndex++) {
                    totalDifference += Math.abs(individual.genome[geneIndex] - TargetGenome[geneIndex]);
                }
                individual.fitness = 1 / (1 + totalDifference);
            });
            Population.sort((a, b) => b.fitness - a.fitness);
        }

        function isTargetReached() {
            return decodeGenomeToString(Population[0].genome) === TargetString;
        }

        function createNewGeneration() {
            const NewGeneration = [];

            const Elite = Population.slice(0, ElitismCount);
            NewGeneration.push(...Elite);

            while (NewGeneration.length < PopulationSize) {
                const ParentA = tournamentSelection();
                const ParentB = tournamentSelection();
                const child = recombination(ParentA, ParentB);
                NewGeneration.push(child);
            }

            Population.length = 0;
            Population.push(...NewGeneration);
        }

        function recombination(parentA, parentB) {
            let childGenome = [];

            for (let geneIndex = 0; geneIndex < TargetGenome.length; geneIndex++) {
                const shouldMutate = Math.random() < MutationChance;
                if (shouldMutate) {
                    childGenome.push(getRandomGene());
                } else {
                    childGenome.push(Math.random() < 0.5 ? parentA.genome[geneIndex] : parentB.genome[geneIndex]);
                }
            }
            return {
                "genome": childGenome,
                "fitness": 0
            };
        }

        function tournamentSelection() {
            const NumParticipants = 2;
            const Participants = [];
            for (let i = 0; i < NumParticipants; i++) {
                const randomIndex = Math.floor(Math.random() * Population.length);
                Participants.push(Population[randomIndex]);
            }
            Participants.sort((a, b) => b.fitness - a.fitness);
            return Participants[0];
        }

        console.log(`Target: "${TargetString}"`);
        console.log("Starting genetic algorithm...");

        const startTime = performance.now();
        createInitialPopulation();

        let generation = 1;
        let isCompleted = false;

        do {
            assignFitnessScore();

            const bestIndividualString = decodeGenomeToString(Population[0].genome);
            console.log(`Generation: ${generation.toString().padStart(4, ' ')} | Best: "${bestIndividualString}" | Fitness: ${Population[0].fitness.toFixed(4)}`);
            
            if (isTargetReached()) {
                isCompleted = true;
                break;
            }
            
            createNewGeneration();
            generation++;
        } while (generation < MaxGenerations);
        

        const endTime = performance.now();
        console.log("-----------------------------------------");
        if (isCompleted) {
            console.log("Success! Target string found.");
        } else {
            console.log("Failure. Target string not found within the generation limit.");
        }
        console.log(`Genetic algorithm ran for ${(endTime - startTime).toFixed(1)} milliseconds.`);

    </script>
</body>
</html>

