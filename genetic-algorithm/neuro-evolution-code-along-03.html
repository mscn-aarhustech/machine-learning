<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Genetic Algorithm with Float Encoding</title>
</head>

<body>
    <h1>Neuroevolution (Output in Console)</h1>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <script type="module">
        "use strict";

        const PopulationSize = 100;
        const MutationChance = 0.1;
        const MaxGenerations = 100;
        const ElitismCount = 5;
        const TargetFitness = 0.8;

        const WeightMin = -10;
        const WeightMax = 10;
        const WeightRange = WeightMax - WeightMin;

        const AndGateTestData = [
            {
                input: [0, 0],
                output: 0
            },
            {
                input: [0, 1],
                output: 0
            },
            {
                input: [1, 0],
                output: 0
            },
            {
                input: [1, 1],
                output: 1
            },
        ];

        const Population = [];

        function encodeNetworkToGenome(network) {
            const genome = [];
            const weightsAndBiases = network.getWeights();
            weightsAndBiases.forEach(tensor => {
                const values = tensor.dataSync();
                for (let i = 0; i < values.length; i++) {
                    const cappedValue = Math.max(WeightMin, Math.min(WeightMax, values[i]));
                    const normalizedValue = (cappedValue - WeightMin) / WeightRange;
                    genome.push(normalizedValue);
                }
            });
            return genome;
        }

        function decodeGenomeToNetwork(genome, neuralNetwork) {

            const shapes = neuralNetwork.getWeights().map(tensor => {
                return { shape: tensor.shape, size: tensor.size };
            });

            const denormalizeWeights = genome.map(gene => gene * WeightRange + WeightMin);

            let index = 0;

            const newTensors = shapes.map(({ shape, size }) => {
                const values = denormalizeWeights.slice(index, index + size);
                index += size;
                return tf.tensor(values, shape);
            });

            neuralNetwork.setWeights(newTensors);
        }

        function getRandomGene() {
            return Math.random();
        }

        function createRandomNetwork() {
            const neuralNetwork = tf.sequential();

            neuralNetwork.add(
                tf.layers.dense(
                    {
                        units: 1,
                        inputShape: [2],
                        activation: 'sigmoid'
                    }
                )
            );

            return neuralNetwork;
        }

        function createRandomIndividual() {
            const neuralNetwork = createRandomNetwork();
            const genome = encodeNetworkToGenome(neuralNetwork);
            const Individual = {
                "genome": genome,
                "fitness": 0
            };
            neuralNetwork.dispose();
            return Individual;
        }

        function createInitialPopulation() {
            Population.length = 0;
            for (let i = 0; i < PopulationSize; i++) {
                const randomIndividual = createRandomIndividual();
                Population.push(randomIndividual);
            }
        }

        async function assignFitnessScore() {
            for (const individual of Population) {
                let totalDifference = 0;
                const genome = individual.genome;
                const nn = createRandomNetwork();
                decodeGenomeToNetwork(genome, nn);
                for (const data of AndGateTestData) {
                    const inputTensor = tf.tensor2d([data.input]);
                    const predictTensor = nn.predict(inputTensor);
                    const predictData = await predictTensor.data();
                    const output = predictData[0];
                    totalDifference += Math.abs(data.output - output);
                    inputTensor.dispose();
                    predictTensor.dispose();
                };
                nn.dispose();
                individual.fitness = 1 / (1 + totalDifference);
            };
            Population.sort((a, b) => b.fitness - a.fitness);
        }

        function isTargetReached() {
            return Population[0].fitness >= TargetFitness;
        }

        function createNewGeneration() {
            const NewGeneration = [];
            const Elite = Population.slice(0, ElitismCount);
            NewGeneration.push(...Elite);
            while (NewGeneration.length < PopulationSize) {
                const ParentA = tournamentSelection();
                const ParentB = tournamentSelection();
                const child = wholeArithmeticRecombination(ParentA, ParentB);
                NewGeneration.push(child);
            }

            Population.length = 0;
            Population.push(...NewGeneration);
        }

        function lerp(a, b, lambda) {
            return a * lambda + b * (1 - lambda);
        }

        function wholeArithmeticRecombination(parentA, parentB) {
            let childGenome = [];
            for (let geneIndex = 0; geneIndex < parentA.genome.length; geneIndex++) {
                const shouldMutate = Math.random() < MutationChance;
                if (shouldMutate) {
                    childGenome.push(getRandomGene());
                } else {
                    const lambda = Math.random();
                    childGenome.push(lerp(parentA.genome[geneIndex], parentB.genome[geneIndex], lambda));
                }
            }
            return {
                "genome": childGenome,
                "fitness": 0
            };
        }

        function tournamentSelection() {
            const NumParticipants = 4;
            const Participants = [];
            for (let i = 0; i < NumParticipants; i++) {
                const randomIndex = Math.floor(Math.random() * Population.length);
                Participants.push(Population[randomIndex]);
            }
            Participants.sort((a, b) => b.fitness - a.fitness);
            return Participants[0];
        }

        async function runEvolution() {
            console.log("Starting genetic algorithm...");

            const startTime = performance.now();
            createInitialPopulation();

            let generation = 1;
            let isCompleted = false;

            do {
                await assignFitnessScore();
                console.log(`Generation: ${generation}, Best Fitness: ${Population[0].fitness.toFixed(4)}`);
                if (isTargetReached()) {
                    console.log(`Target reached at generation ${generation}!`);
                    isCompleted = true;
                    break;
                }
                createNewGeneration();
                generation++;
            } while (generation < MaxGenerations);

            if (!isCompleted) {
                console.log("Max generations reached.");
            }

            console.log("Best individual found:", Population[0]);

            const genome = Population[0].genome;
            const nn = createRandomNetwork();
            decodeGenomeToNetwork(genome, nn);

            console.log("\n--- Testing Best Individual ---");

            for (const data of AndGateTestData) {
                const inputTensor = tf.tensor2d([data.input]);
                const predictTensor = nn.predict(inputTensor);
                const predictData = await predictTensor.data();
                const output = predictData[0];

                console.log(`Input: [${data.input.join(', ')}], Prediction: ${output.toFixed(4)}, Correct Answer: ${data.output}`);

                inputTensor.dispose();
                predictTensor.dispose();
            };

            const finalWeights = nn.getWeights();
            const weights = finalWeights[0].dataSync();
            const bias = finalWeights[1].dataSync();
            console.log(`\n--- Best Individual's Network ---`);
            console.log(`Weights: [w1: ${weights[0].toFixed(4)}, w2: ${weights[1].toFixed(4)}]`);
            console.log(`Bias: ${bias[0].toFixed(4)}`);

            nn.dispose();
            const endTime = performance.now();
            console.log(`\nGenetic algorithm ran for ${(endTime - startTime).toFixed(1)} milliseconds.`);
        }

        runEvolution();
    </script>
</body>

</html>